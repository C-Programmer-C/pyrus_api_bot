declare module "pyrus-api" {
	export enum OperatorId {
		Equals = 1,
		LessThan = 2,
		GreaterThan = 3,
		IsIn = 4,
		Range = 5,
		MatchPrefix = 6,
		IsEmpty = 7
	}
	export type FormFilter = {
		field_id: number;
		operator_id: OperatorId;
		values: string[];
	};
	export type CatalogHeader = {
		name: string;
		type: CatalogHeaderType;
	};
	enum CatalogHeaderType {
		Text = "text",
		Workflow = "workflow"
	}
	export function toJson(obj: any): string;
	export function fromJson<T = any>(str: string): T;
	export function toDateTimeString(date: Date | string): string;
	export function toDateString(date: Date | string): string;
	export function toTimeString(date: Date | string): string;
	export function prepareHeadersForCatalogApiRequest(headers: string[] | CatalogHeader[]): string[];
	export const ErrorCodeType: {
		readonly ServerError: "server_error";
		readonly AuthorizationError: "authorization_error";
		readonly TokenNotSpecified: "token_not_specified";
		readonly RevokedToken: "revoked_token";
		readonly ExpiredToken: "expired_token";
		readonly InvalidToken: "invalid_token";
		readonly AccountBlocked: "account_blocked";
		readonly InvalidCredentials: "invalid_credentials";
		readonly InvalidApplicationId: "invalid_application_id";
		readonly InvalidFieldId: "invalid_field_id";
		readonly InvalidFieldName: "invalid_field_name";
		readonly InvalidFieldIdName: "invalid_field_id_name";
		readonly NonUniqueName: "non_unique_name";
		readonly FieldIdentityMissing: "field_identity_missing";
		readonly DuplicateField: "duplicate_field";
		readonly InvalidCatalogId: "invalid_catalog_id";
		readonly InvalidCatalogItemName: "invalid_catalog_item_name";
		readonly NonUniqueCatalogItemName: "non_unique_catalog_item_name";
		readonly InvalidCatalogItemId: "invalid_catalog_item_id";
		readonly InvalidCatalogItemIdName: "catalog_item_id_name_mismatch";
		readonly InvalidEmail: "invalid_email";
		readonly NonUniqueEmail: "non_unique_email";
		readonly InvalidPersonIdEmail: "invalid_person_id_email";
		readonly UnrecognizedAttachmentId: "unrecognized_attachment_id";
		readonly RequiredFieldMissing: "required_field_missing";
		readonly FieldTypeIsNotSupported: "type_is_not_supported";
		readonly IncorrectParametersCount: "incorrect_parameters_count";
		readonly FilterTypeIsNotSupported: "filter_type_is_not_supported";
		readonly StepFieldDoesNotExists: "step_field_does_not_exists";
		readonly NoFileInRequest: "no_file_in_request";
		readonly TooLargeRequestLength: "too_large_request_length";
		readonly TaskHasNoForm: "task_has_no_form";
		readonly RequiredParameterMissing: "required_parameter_missing";
		readonly InvalidValueFormat: "invalid_value_format";
		readonly InvalidJson: "invalid_json";
		readonly EmptyBody: "empty_body";
		readonly TextMissing: "text_missing";
		readonly FormIdMissing: "form_id_missing";
		readonly InvalidPersonId: "invalid_person_id";
		readonly DeletedField: "deleted_field";
		readonly PersonIdentityMissing: "person_identity_missing";
		readonly CatalogItemIdMissing: "catalog_identity_missing";
		readonly FormHasNoTask: "form_has_no_task";
		readonly EitherDueDateOrDueCanBeSet: "either_due_date_or_due_can_be_set";
		readonly NegativeDuration: "negative_duration";
		readonly DurationIsTooLong: "duration_is_too_long";
		readonly DueMissing: "due_missing";
		readonly ScheduledDateInPast: "scheduled_date_in_past";
		readonly CannotAddFormProject: "cannot_add_form_project";
		readonly FormTemplateCantBeRemovedFromTask: "form_template_cant_be_removed_from_task";
		readonly TooManyTaskSteps: "too_many_task_steps";
		readonly TooManyComments: "too_many_comments";
		readonly InvalidStepNumber: "invalid_step_number";
		readonly TaskLimitExceeded: "task_limit_exceeded";
		readonly FieldIsInTable: "field_is_in_table";
		readonly RequiredTableFieldMissing: "required_table_field_missing";
		readonly DepartmentCatalogCanNotBeModified: "department_catalog_can_not_be_modified";
		readonly CatalogDuplicateItems: "catalog_duplicate_rows";
		readonly EmptyCatalogHeaders: "empty_catalog_headers";
		readonly CanNotModifyDeletedCatalog: "can_not_modify_deleted_catalog";
		readonly CatalogDuplicateHeaders: "catalog_duplicate_headers";
		readonly CanNotModifyFirstColumn: "can_not_modify_first_column";
		readonly CatalogHeadersItemsMismatch: "catalog_headers_items_mismatch";
		readonly TooManyCatalogItems: "too_many_catalog_items";
		readonly CatalogItemMaxLengthExceeded: "catalog_item_max_length_exceeded";
		readonly SingleValueIsNotSupported: "single_value_is_not_supported";
		readonly ParticipantLimitExceeded: "participant_limit_exceeded";
		readonly TableRowsLimitExceeded: "table_rows_limit_exceeded";
		readonly TextFieldValueLimitExceeded: "text_field_value_limit_exceeded";
		readonly UnableToEditField: "unable_to_edit_field";
		readonly EmptyFile: "empty_file";
		readonly BadMultipartContent: "bad_multipart_content";
		readonly TooManyDecimalPlaces: "too_many_decimal_places";
		readonly ExternalCommentEmptyText: "external_comment_empty_text";
		readonly SenderAddressFieldMissing: "sender_address_field_missing";
		readonly ExternalCommentRecipientNotFound: "external_comment_recipient_not_found";
		readonly DefaultMailboxNotFound: "default_mailbox_not_found";
		readonly CatalogNullValue: "catalog_null_value";
		readonly MaxTextLengthExceeded: "max_text_length_exceeded";
		readonly DueOutsideOfBounds: "due_outside_of_bounds";
		readonly AttachmentsForbidden: "attachments_forbidden";
		readonly UnrecognizedCallGuid: "unrecognized_call_guid";
		readonly UnsupportedAttachmentFormat: "unsupported_attachment_format";
		readonly ValidationError: "validation_error";
		readonly UnrecognizedAccountId: "unrecognized_account_id";
		readonly WebhookIsDisabled: "webhook_is_disabled";
		readonly TooLargeMessageText: "too_large_message_text";
		readonly UnrecognizedMessageType: "unrecognized_message_type";
		readonly InvalidFieldMappingCode: "invalid_field_mapping_code";
		readonly TooManyAttachments: "too_many_attachments";
		readonly UnrecognizedCallId: "unrecognized_call_id";
		readonly UnsupportedRecordFileFormat: "unsupported_record_file_format";
		readonly UnrecognizedIntegrationGuid: "unrecognized_integration_guid";
		readonly LimitExceeded: "limit_exceeded";
		readonly MaxSmsTextLengthExceeded: "max_sms_text_length_exceeded";
		readonly SmsIntegrationNotConfigured: "sms_integration_not_configured";
		readonly AttachmentTooBig: "attachment_too_big";
		readonly UncreatedOrDeletedTableRows: "invalid_table_row";
		readonly PrivateChannelAccessDenied: "private_channel_access_denied";
		readonly PrivateCommentHasForbiddenChanges: "private_comment_has_forbidden_changes";
		readonly ItemsCountOutOfRange: "items_count_out_of_range";
		readonly CannotAddExternalUser: "cannot_add_external_user";
		readonly UnrecognizedTaskId: "unrecognized_task_id";
		readonly TooManyDeletedCatalogItems: "too_many_deleted_catalog_items";
		readonly FieldCannotHaveMultipleValues: "field_cannot_have_multiple_values";
		readonly FieldEditingIsNotAllowed: "field_editing_is_not_allowed";
		readonly NonUniqueCode: "non_unique_code";
		readonly InvalidFieldCode: "invalid_field_code";
		readonly AccessDeniedProject: "access_denied_project";
		readonly AccessDeniedTask: "access_denied_task";
		readonly AccessDeniedCatalog: "access_denied_catalog";
		readonly AccessDeniedForm: "access_denied_form";
		readonly AccessDeniedPerson: "access_denied_person";
		readonly AccessDeniedCloseTask: "access_denied_close_task";
		readonly AccessDeniedReopenTask: "access_denied_reopen_task";
		readonly AccessDeniedFileAccessHistory: "access_denied_file_access_history";
		readonly AccessDeniedFile: "access_denied_file";
		readonly AccessDeniedReport: "access_denied_report";
		readonly AccessDenied: "access_denied";
		readonly FileIsMissing: "file_is_missing";
		readonly TooManyRequests: "too_many_requests";
	};
	export type ErrorCodeType = typeof ErrorCodeType[keyof typeof ErrorCodeType];
	export type ErrorResponse = {
		error: string;
		error_code: ErrorCodeType;
		error_message?: string;
	};
	export class ApiError extends Error {
		name: string;
		readonly errorCode: ErrorCodeType;
		constructor({ code, error }: {
			code: number;
			error: ErrorResponse;
		});
	}
	export const FilterMask: {
		/**
		 *  Events whose deadline is indicated in UTC+0
		 */
		readonly Due: 1;
		/**
		 * Tasks whose deadline is indicated by date
		 * (without reference to timezone)
		 */
		readonly DueDate: 2;
		/**
		 * Tasks whose deadline at the current step is
		 * within the selected time period in UTC+0
		 */
		readonly DueForCurrentStep: 4;
		/**
		 *  Tasks with a programmed reminder
		 */
		readonly Reminded: 8;
	};
	export type FilterMask = typeof FilterMask[keyof typeof FilterMask];
	export const CallEventType: {
		readonly Show: "show";
	};
	export type CallEventType = typeof CallEventType[keyof typeof CallEventType];
	export const SourceType: {
		readonly Default: "default";
		readonly FillTable: "fill_table";
	};
	export type SourceType = typeof SourceType[keyof typeof SourceType];
	export const ActivityAction: {
		readonly Finished: "finished";
		readonly Reopened: "reopened";
	};
	export type ActivityAction = typeof ActivityAction[keyof typeof ActivityAction];
	export const ApprovalChoice: {
		readonly Waiting: "waiting";
		readonly Approved: "approved";
		readonly Rejected: "rejected";
		readonly Revoked: "revoked";
		readonly Acknowledged: "acknowledged";
	};
	export type ApprovalChoice = typeof ApprovalChoice[keyof typeof ApprovalChoice];
	export enum PersonRights {
		None = 0,
		ManageRoles = 1,
		CanSeeAllTasks = 2,
		ManagePersonsInOrganization = 4,
		EditOrganizationProjects = 8,
		EditOrganizationSettings = 16,
		DeleteMyTasksAndProjects = 32,
		CloseDeleteAnnouncements = 64,
		BillsPayment = 128,
		InvitePersonsToOrganization = 256,
		DeleteOtherMembersTasks = 512,
		ManageIntegrationsAndCatalogs = 1024,
		CreateAnnouncement = 2048,
		CanDeleteTaskFlagEquivalent = 544,
		SupervisorRights = 221,
		MaxAdditionalRights = 2047,
		NewOrganizationDefaultRights = 2080,
		UIOrganizationManager = 277,
		UIAccountant = 128,
		UISupervisor = 10,
		UIConfigurationManager = 1600,
		UIAdministrator = 2015
	}
	export const ListType: {
		readonly Private: "private";
		readonly OrganizationWide: "org_wide";
	};
	export type ListType = typeof ListType[keyof typeof ListType];
	export const Flag: {
		readonly None: "none";
		readonly Checked: "checked";
		readonly Unchecked: "unchecked";
	};
	export type Flag = typeof Flag[keyof typeof Flag];
	export const FormFieldType: {
		readonly Unknown: "unknown";
		readonly Text: "text";
		readonly Money: "money";
		readonly Number: "number";
		readonly Date: "date";
		readonly Time: "time";
		readonly Checkmark: "checkmark";
		readonly MultipleChoice: "multiple_choice";
		readonly DueDate: "due_date";
		readonly Email: "email";
		readonly Phone: "phone";
		readonly Flag: "flag";
		readonly Step: "step";
		readonly Status: "status";
		readonly CreationDate: "creation_date";
		readonly Note: "note";
		readonly Catalog: "catalog";
		readonly File: "file";
		readonly Person: "person";
		readonly Author: "author";
		readonly Table: "table";
		readonly Title: "title";
		readonly Project: "project";
		readonly FormLink: "form_link";
		readonly DueDateTime: "due_date_time";
	};
	export type FormFieldType = typeof FormFieldType[keyof typeof FormFieldType];
	export const PermissionLevel: {
		readonly None: "none";
		readonly Manager: "manager";
		readonly Member: "member";
		readonly Administrator: "administrator";
	};
	export type PermissionLevel = typeof PermissionLevel[keyof typeof PermissionLevel];
	export const PersonType: {
		readonly User: "user";
		readonly Bot: "bot";
		readonly Role: "role";
	};
	export type PersonType = typeof PersonType[keyof typeof PersonType];
	export const SendSmsError: {
		readonly None: "none";
		readonly Unknown: "unknown";
		readonly Expired: "expired";
		readonly Forbidden: "forbidden";
		readonly Unreachable: "unreachable";
		readonly UnknownStatus: "unknown_status";
		readonly UnableToDeliver: "unable_to_deliver";
		readonly InvalidPhoneNumber: "invalid_phone_number";
		readonly Rejected: "rejected";
	};
	export type SendSmsError = typeof SendSmsError[keyof typeof SendSmsError];
	export const SendSmsStatus: {
		readonly Sent: "sent";
		readonly Delivered: "delivered";
		readonly DeliveryFailed: "delivery_failed";
		readonly SendFailed: "send_failed";
	};
	export type SendSmsStatus = typeof SendSmsStatus[keyof typeof SendSmsStatus];
	export type NewFile = {
		guid?: string;
		root_id?: number;
		attachment_id?: number;
		url?: string;
		name?: string;
	};
	/**
	 * Data for autofilling form fields
	 */
	export type FormMapping = {
		/**
		 * Pyrus form field symbol code
		 */
		code: string;
		/**
		 * Pyrus field value
		 *
		 * @remarks
		 * 300 symbols max
		 */
		value: string;
	};
	export type CatalogItem = {
		item_id?: number;
		external_id?: number;
		values: string[];
		deleted?: boolean;
		links?: CatalogItemLink[];
	};
	export type CatalogItemLink = {
		item_id: number;
		catalog_id: number;
	};
	export type ColumnSettings = {
		original_position?: number;
		sort_order?: number;
		visible?: boolean;
		group_by?: boolean;
	};
	export type DueFilter = {
		overdue_steps: number[];
	};
	export type FormFieldInfo = {
		required_step?: number;
		immutable_step?: number;
		options?: ChoiceOption[];
		catalog_id?: number;
		columns?: FormField[];
		fields?: FormField[];
		form_id?: number;
		code?: string;
		decimal_places?: number;
		multiple_choice?: boolean;
		multiline?: boolean;
	};
	export type ChoiceOption = {
		choice_id: number;
		choice_value: string;
		deleted: boolean;
		fields: FormField[];
	};
	export type FormFieldBase = {
		id?: number;
		type?: FormFieldType;
		name?: string;
		info?: FormFieldInfo;
		parent_id?: number;
		row_id?: number;
		code?: string;
	};
	export type Person = {
		id: number;
		first_name: string;
		last_name: string;
		native_first_name?: string;
		native_last_name?: string;
		email: string;
		status?: string;
		type: PersonType;
		department_id?: string;
		department_name?: string;
		banned: boolean;
		fired?: boolean;
		task_receiver?: number;
		position: string;
		skype: string;
		phone: string;
	};
	export type FormFieldAuthor = FormFieldBase & {
		type?: typeof FormFieldType.Author;
		value?: Person;
	};
	export type FormFieldCatalog = FormFieldBase & {
		type?: typeof FormFieldType.Catalog;
		value?: Catalog;
	};
	export type Catalog = {
		item_id: number;
		item_ids?: number[];
		item_names?: string[];
		headers?: string[];
		values?: string[];
		rows?: string[][];
	};
	const Checkmark: {
		readonly Checked: "checked";
		readonly Unchecked: "unchecked";
	};
	export type Checkmark = typeof Checkmark[keyof typeof Checkmark];
	export type FormFieldCheckmark = FormFieldBase & {
		type?: typeof FormFieldType.Checkmark;
		value?: Checkmark;
	};
	export type FormFieldCreateDate = FormFieldBase & {
		type: typeof FormFieldType.CreationDate;
		value?: Date;
	};
	export type FormFieldDate = FormFieldBase & {
		type: typeof FormFieldType.Date;
		value?: Date;
	};
	export type FormFieldDueDate = FormFieldBase & {
		type: typeof FormFieldType.DueDate;
		value?: Date;
	};
	export type FormFieldDueDateTime = FormFieldBase & {
		type: typeof FormFieldType.DueDateTime;
		value?: Date;
	};
	export type FormFieldEmail = FormFieldBase & {
		type?: typeof FormFieldType.Email;
		value?: string;
	};
	export type AttachedFile = {
		id: number;
		name: string;
		size: number;
		md5: string;
		url: string;
		version: number;
		root_id?: number;
	};
	export type FormFieldFile = FormFieldBase & {
		type?: typeof FormFieldType.File;
		value?: AttachedFile[];
	};
	export type FormFieldFlag = FormFieldBase & {
		type?: typeof FormFieldType.Flag;
		value?: Flag;
	};
	export type FormLink = {
		task_id?: number;
		task_ids?: number[];
		subject?: string;
	};
	export type FormFieldFormLink = FormFieldBase & {
		type?: typeof FormFieldType.FormLink;
		value?: FormLink;
	};
	export type FormFieldMoney = FormFieldBase & {
		type?: typeof FormFieldType.Money;
		value?: number;
	};
	export type FormFieldMultipleChoice = FormFieldBase & {
		type?: typeof FormFieldType.MultipleChoice;
		value?: MultipleChoice;
	};
	export type MultipleChoice = {
		choice_id?: number;
		choice_ids?: number[];
		choice_names?: string[];
		fields?: FormField[];
	};
	export type FormFieldNewFile = FormFieldFile & {
		value?: NewFile[];
	};
	export type FormFieldNote = FormFieldBase & {
		type?: typeof FormFieldType.Note;
		value?: string;
	};
	export type FormFieldNumber = FormFieldBase & {
		type?: typeof FormFieldType.Number;
		value?: number;
	};
	export type FormFieldPerson = FormFieldBase & {
		type?: typeof FormFieldType.Person;
		value?: Person;
	};
	export type FormFieldPhone = FormFieldBase & {
		type?: typeof FormFieldType.Phone;
		value?: string;
	};
	export type FormFieldProject = FormFieldBase & {
		type?: typeof FormFieldType.Project;
		value?: ProjectArray;
	};
	export type ProjectArray = {
		projects: Project[];
	};
	export type Project = {
		id: number;
		name?: string;
		parent?: Project;
	};
	const Status: {
		readonly Open: "open";
		readonly Closed: "closed";
	};
	export type Status = typeof Status[keyof typeof Status];
	export type FormFieldStatus = FormFieldBase & {
		type?: typeof FormFieldType.Status;
		value?: Status;
	};
	export type FormFieldStep = FormFieldBase & {
		type?: typeof FormFieldType.Step;
		value?: number;
	};
	export type FormFieldTable = FormFieldBase & {
		type?: typeof FormFieldType.Table;
		value?: TableRow[];
	};
	export type TableRow = {
		row_id: number;
		cells?: FormField[];
		delete?: boolean;
		deleted?: boolean;
	};
	export type FormFieldText = FormFieldBase & {
		type?: typeof FormFieldType.Text;
		value?: string;
	};
	export type FormFieldTime = FormFieldBase & {
		type: typeof FormFieldType.Time;
		value?: Date;
	};
	export type FormFieldTitle = FormFieldBase & {
		type?: typeof FormFieldType.Title;
		value?: Title;
	};
	export type Title = {
		checkmark?: Checkmark;
		fields?: FormField[];
	};
	export type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";
	export type ById = {
		id: number;
	};
	export type IdOrCodeRequired = {
		id: number;
	} | {
		code: string;
	};
	export type FormField = FormFieldAuthor | FormFieldCatalog | FormFieldCheckmark | FormFieldCreateDate | FormFieldDate | FormFieldDueDate | FormFieldDueDateTime | FormFieldEmail | FormFieldFile | FormFieldFlag | FormFieldFormLink | FormFieldMoney | FormFieldMultipleChoice | FormFieldNewFile | FormFieldNote | FormFieldNumber | FormFieldPerson | FormFieldPhone | FormFieldProject | FormFieldStatus | FormFieldStep | FormFieldTable | FormFieldText | FormFieldTime | FormFieldTitle;
	export type FormFieldIdentified = FormField & IdOrCodeRequired;
	const ChannelType: {
		readonly Email: "email";
		readonly Telegram: "telegram";
		readonly Web: "web";
		readonly Facebook: "facebook";
		readonly Vk: "vk";
		readonly Viber: "viber";
		readonly MobileApp: "mobile_app";
		readonly WebWidget: "web_widget";
		readonly MoySklad: "moy_sklad";
		readonly Zadarma: "zadarma";
		readonly AmoCrm: "amo_crm";
		readonly Instagram: "instagram";
		readonly PrivateChannel: "private_channel";
		readonly Jira: "jira";
		readonly Beeline: "beeline";
		readonly ApiTelephony: "api_telephony";
		readonly Zoom: "zoom";
		readonly WebForm: "web_form";
		readonly WhatsApp: "whats_app";
		readonly Custom: "custom";
		readonly Sms: "sms";
	};
	export type ChannelType = typeof ChannelType[keyof typeof ChannelType];
	export type ChannelUser = {
		email?: string;
		name?: string;
	};
	export type Channel = {
		type: ChannelType;
		phone?: string;
		to?: ChannelUser;
		from?: ChannelUser;
	};
	export type PersonIdentity = {
		id: number;
	} | {
		email: string;
	};
	export type TaskCommentRequest = {
		text?: string;
		formatted_text?: string;
		subject?: string;
		approval_choice?: ApprovalChoice;
		reassign_to?: PersonIdentity;
		approval_steps?: number[];
		action?: ActivityAction;
		attachments?: NewFile[];
		field_updates?: FormFieldIdentified[];
		approvals_added?: PersonIdentity[][];
		approvals_removed?: PersonIdentity[][];
		approvals_rerequested?: PersonIdentity[][];
		subscribers_added?: PersonIdentity[];
		subscribers_removed?: PersonIdentity[];
		subscribers_rerequested?: PersonIdentity[];
		participants_added?: PersonIdentity[];
		participants_removed?: PersonIdentity[];
		due_date?: Date;
		due?: Date;
		duration?: number;
		cancel_due?: boolean;
		scheduled_date?: Date;
		scheduled_datetime_utc?: Date;
		cancel_schedule?: boolean;
		added_list_ids?: number[];
		removed_list_ids?: number[];
		channel?: Channel;
		spent_minutes?: number;
		skip_satisfaction?: boolean;
		edit_comment_id?: number;
		skip_notification?: boolean;
	};
	export type CommentDescription = {
		task_id: number;
		previous_note_id: number;
		comment: TaskCommentRequest;
	};
	export type Approval = {
		person: Person;
		approval_choice?: ApprovalChoice;
		step?: number;
	};
	export type Subscriber = {
		person: Person;
		approval_choice?: ApprovalChoice;
	};
	export type TaskHeader = {
		id: number;
		text: string;
		create_date: Date;
		last_modified_date: Date;
		author: Person;
		close_date?: Date;
		responsible?: Person;
		due_date?: Date;
	};
	export type Task = TaskHeader & {
		due_date?: Date;
		due?: Date;
		scheduled_date?: Date;
		scheduled_datetime_utc?: Date;
		cancel_schedule?: boolean;
		duration?: number;
		form_id?: number;
		attachments?: AttachedFile[];
		fields?: FormField[];
		approvals?: Approval[][];
		subscribers?: Subscriber[];
		participants?: Person[];
		list_ids?: number[];
		linked_task_ids?: number[];
		parent_task_id?: number;
		last_note_id?: number;
		subject?: string;
		current_step?: number;
		is_closed: boolean;
	};
	export type Role = {
		id: number;
		name: string;
		external_id?: string;
		avatar_id?: number;
		external_avatar_id?: number;
		banned: boolean;
		fired?: boolean;
		member_ids: number[];
	};
	export type SmsInfo = {
		error_code?: SendSmsError;
		status: SendSmsStatus;
		error_message?: string;
		sent_comment_id: number;
	};
	export type TaskComment = {
		id: number;
		text: string;
		formatted_text?: string;
		mentions?: number[];
		subject?: string;
		create_date: Date;
		author: Person;
		reassigned_to?: Person;
		field_updates?: FormField[];
		approval_choice?: ApprovalChoice;
		reset_to_step?: number;
		reply_note_id?: number;
		approvals_added?: Approval[][];
		approvals_removed?: Approval[][];
		approvals_rerequested?: Approval[][];
		subscribers_added?: Person[];
		subscribers_removed?: Person[];
		participants_added?: Person[];
		participants_removed?: Person[];
		due_date?: Date;
		due?: Date;
		scheduled_date?: Date;
		scheduled_datetime_utc?: Date;
		cancel_schedule?: boolean;
		duration?: number;
		attachments?: AttachedFile[];
		action?: ActivityAction;
		added_list_ids?: number[];
		removed_list_ids?: number[];
		approval_step?: number;
		comment_as_roles?: Role[];
		changed_step?: number;
		channel?: Channel;
		edit_comment_id?: number;
		removed_attachment_ids?: number[];
		delete_comment_id?: number;
		spent_minutes?: number;
		skip_satisfaction?: boolean;
		sms_info?: SmsInfo;
	};
	export type Step = {
		step: number;
		elapsed_time: number;
		name?: string;
	};
	export type TaskWithComments = Task & {
		comments: TaskComment[];
		steps?: Step[];
	};
	export type TaskResponse = {
		task: TaskWithComments;
	};
	export type BotHookRequest = TaskResponse & {
		event: "comment" | "close";
		access_token: string;
		user_id: number;
		bot_settings: string;
		task_id: number;
	};
	export type BotHookResponse = TaskCommentRequest | void;
	export type AuthRequest = {
		login: string;
		security_key: string;
		/**
		 * Employee ID
		 * @remarks
		 *  if you have more than one account registered to the same email,
		 *  then to receive a token you need to add the person_id parameter
		 */
		person_id?: string;
	};
	export type Settings = {
		apiUrl?: string;
		authUrl: string;
		filesUrl?: string;
	};
	export type AuthResponse = {
		access_token: string;
		api_url?: string;
		files_url?: string;
	};
	export interface BaseApiParams {
		token?: string;
		settings?: Settings;
		authRequest?: Promise<AuthResponse>;
	}
	abstract class BaseApi {
		protected _token: string;
		protected _settings: Settings;
		protected _authRequest: Promise<AuthResponse>;
		protected _moduleSubPath: string;
		protected constructor({ token, authRequest, settings }: BaseApiParams);
		protected loginDone(): Promise<void>;
		protected fetchApi<T>(url: string, method: HTTPMethod, body?: BodyInit, headersOverride?: HeadersInit): Promise<T>;
		protected _checkResponse(resp: Response): Promise<any>;
		protected getModulePath(): Promise<string>;
		protected authorisationHeader(): Promise<Record<string, string>>;
		private defaultHeaders;
	}
	export type CreateRoleRequest = {
		name: string;
		external_id?: string;
		member_add?: number[];
	};
	enum Endpoints {
		Auth = "/auth",
		Roles = "/roles",
		Profile = "/profile",
		Contacts = "/contacts",
		Files = "/files",
		V4 = "/v4",
		Upload = "/upload",
		Download = "/download",
		Lists = "/lists",
		Inbox = "/inbox",
		ListTasks = "/tasks",
		Calendar = "/calendar",
		Announcements = "/announcements",
		AnnouncementComments = "/comments",
		Catalogs = "/catalogs",
		Members = "/members",
		Tasks = "/tasks",
		TasksComments = "/comments",
		Forms = "/forms",
		FormsRegister = "/register",
		FormsPermissions = "/permissions",
		EventHistory = "/eventhistory",
		FileAccessHistory = "/fileaccesshistory",
		TaskAccessHistory = "/taskaccesshistory",
		TaskExportHistory = "/taskexporthistory",
		RegistryDownloadHistory = "/registrydownloadhistory",
		Integrations = "/integrations",
		Call = "/call",
		AttachCallRecord = "/attachcallrecord",
		Bots = "/bots"
	}
	export type RolesResponse = {
		roles: Role[];
	};
	export type UpdateRoleRequest = {
		id: number;
		name?: string;
		external_id?: string;
		banned?: boolean;
		member_add?: number[];
		member_remove?: number[];
	};
	export type GetAllRequest = {
		include_fired: boolean;
	};
	class RoleApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		create(request: CreateRoleRequest): Promise<Role>;
		get({ id }: ById): Promise<Role>;
		getAll(request?: GetAllRequest): Promise<RolesResponse>;
		update(request: UpdateRoleRequest): Promise<Role>;
	}
	export type Organization = {
		organization_id: number;
		name: string;
		persons: Person[];
		roles: Role[];
		department_catalog_id?: number;
	};
	export type ProfileResponse = {
		person_id: number;
		first_name?: string;
		last_name?: string;
		email: string;
		locale?: string;
		organization_id: number;
		organization: Organization;
		timezone_offset?: number;
	};
	export type ProfileRequest = {
		include_inactive: boolean;
	};
	class ProfileApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		get(request?: ProfileRequest): Promise<ProfileResponse>;
	}
	export type ContactsRequest = {
		include_inactive?: boolean;
	};
	export type ContactsResponse = {
		organizations: Organization[];
	};
	class ContactsApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		getAll(request?: ContactsRequest): Promise<ContactsResponse>;
	}
	export type UploadResponse = {
		guid: string;
		md5_hash: string;
	};
	class FilesApi extends BaseApi {
		upload(file: Blob, filename: string): Promise<UploadResponse>;
		download({ id }: ById): Promise<Blob>;
		private _filePath;
	}
	export type PlainTaskList = {
		id: number;
		parent_id?: number;
		name: string;
		color?: string;
		deleted: boolean;
		list_type: ListType;
		has_form?: boolean;
		manager_ids: number[];
		member_ids?: number[];
		version: number;
		external_version?: number;
		external_id?: number;
	};
	export type TaskList = PlainTaskList & {
		children?: TaskList[];
	};
	export type ListsResponse = {
		lists: TaskList[];
	};
	export type TaskListRequest = {
		include_archived?: "y";
		modified_before?: Date;
		modified_after?: Date;
		/**
		 * @remarks
		 * Default: 200
		 */
		item_count?: number;
	};
	export type TaskListResponse = {
		tasks: TaskHeader[];
		has_more: boolean;
	};
	export type InboxRequest = {
		/**
		 * The maximum number of tasks in the response
		 * @remarks
		 * default: 50
		 */
		item_count: number;
	};
	export type CreateListRequest = {
		parent_id?: number;
		name: string;
		color?: string;
		list_type?: ListType;
		added_managers?: number[];
		added_members?: number[];
		external_version?: number;
		external_id?: number;
		is_private?: boolean;
	};
	export type UpdateListRequest = {
		id: number;
		name?: string;
		color?: string;
		list_type?: ListType;
		added_managers?: number[];
		removed_managers?: number[];
		added_members?: number[];
		removed_members?: number[];
		external_version?: number;
		external_id?: number;
		is_private?: boolean;
	};
	class ListsApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		getAll(): Promise<ListsResponse>;
		getTasksInList(listId: number, request?: TaskListRequest): Promise<TaskListResponse>;
		getInbox(request?: InboxRequest): Promise<TaskListResponse>;
		create(request: CreateListRequest): Promise<PlainTaskList>;
		get(request: ById): Promise<TaskList>;
		delete(request: ById): Promise<void>;
		update(request: UpdateListRequest): Promise<PlainTaskList>;
	}
	export type CalendarTasksRequest = {
		start_date_utc?: Date;
		end_date_utc: Date;
		/**
		 * Maximum number of tasks that will be returned in reply
		 * @remarks
		 * 50 default, 100 max
		 */
		item_count?: number;
		/**
		 * @remarks
		 * Whether all tasks accessible to user must be returned,
		 * including all roles of user and all tasks from forms
		 * accessible to user. Otherwise, only tasks where the user
		 * is an assignee or approver, that have not yet been approved,
		 * will be returned.
		 */
		all_accessed_tasks?: boolean;
		/**
		 * Bit mask that determines filter combination
		 */
		filter_mask?: FilterMask;
	};
	export type CalendarResponse = {
		tasks: TaskWithComments[];
		has_more: boolean;
	};
	class CalendarApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		getTasks(request: CalendarTasksRequest): Promise<CalendarResponse>;
	}
	export type AnnouncementComment = {
		id: number;
		text?: string;
		formatted_text?: string;
		create_date: Date;
		author: Person;
		attachments?: AttachedFile[];
		comments?: TaskComment[];
	};
	export type AnnouncementWithComments = {
		id: number;
		text: string;
		formatted_text: string;
		create_date: Date;
		last_modified_date: Date;
		author: Person;
		attachments?: AttachedFile[];
		comments?: AnnouncementComment[];
	};
	export type AnnouncementsResponse = {
		announcements: AnnouncementWithComments[];
	};
	export type AnnouncementResponse = {
		announcement: AnnouncementWithComments;
	};
	export type AnnouncementRequest = {
		text: string;
		formatted_text?: string;
		attachments?: NewFile[];
	};
	export type AnnouncementCommentRequest = {
		text?: string;
		formatted_text?: string;
		attachments?: NewFile[];
	};
	class AnnouncementsApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		getAll(): Promise<AnnouncementsResponse>;
		get({ id }: ById): Promise<AnnouncementResponse>;
		create(request: AnnouncementRequest): Promise<AnnouncementResponse>;
		addComment(id: number, request: AnnouncementCommentRequest): Promise<AnnouncementResponse>;
	}
	export type CatalogInfo = {
		catalog_id: number;
		name: number;
		source_type: SourceType;
		external_id?: string;
		version: number;
		external_version?: number;
		deleted: boolean;
		supervisors?: number[];
		column_settings?: ColumnSettings[];
		links?: CatalogLink[];
	};
	export type CatalogLink = {
		catalog_id: number;
		column_name: string;
	};
	export type CatalogsResponse = {
		catalogs: CatalogInfo[];
	};
	export type CatalogItemResponse = CatalogItem & {
		item_id: number;
	};
	export type CatalogResponse = {
		catalog_id: number;
		name: string;
		external_id?: string;
		version: number;
		external_version?: number;
		deleted: boolean;
		supervisors?: number[];
		catalog_headers: CatalogHeader[];
		column_settings?: ColumnSettings[];
		items?: CatalogItemResponse[];
		source_type: SourceType;
	};
	export type CatalogRequestBase = {
		id?: number;
		external_id?: string;
		name?: string;
		external_version?: number;
		catalog_headers: string[];
		items?: CatalogItem[];
		add_supervisors?: number[];
		remove_supervisors?: number[];
		add_workflow_headers?: string[];
		delete_workflow_headers?: string[];
		column_settings?: ColumnSettings[];
	};
	export type CreateCatalogRequest = CatalogRequestBase & {
		name: string;
		source_type?: SourceType;
	};
	export type SyncCatalogRequestApi = CatalogRequestBase & {
		id: number;
		apply: boolean;
		force_update_first_column?: boolean;
	};
	export type SyncCatalogRequest = Omit<SyncCatalogRequestApi, "catalog_headers"> & {
		catalog_headers: string[] | CatalogHeader[];
	};
	export type SyncCatalogResponse = {
		apply: boolean;
		added?: CatalogItemResponse[];
		deleted?: CatalogItemResponse[];
		updated?: CatalogItemResponse[];
		catalog_headers: CatalogHeader[];
	};
	class CatalogsApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		getAll(): Promise<CatalogsResponse>;
		get({ id }: ById): Promise<CatalogResponse>;
		create(request: CreateCatalogRequest): Promise<CatalogResponse>;
		/**
		 *  This method updates catalog headers and items.
		 *  You must define all the values and text columns that need to remain in the catalog.
		 *
		 *  All unspecified items and text columns will be deleted
		 * @param request
		 */
		sync(request: SyncCatalogRequest): Promise<SyncCatalogResponse>;
	}
	export type MembersResponse = {
		members: Person[];
	};
	export type CreateMemberRequest = {
		first_name?: string;
		last_name?: string;
		email: string;
		status?: string;
		position?: string;
		department_id?: number;
		skype?: string;
		phone?: string;
		external_id?: string;
		login_phone?: string;
	};
	export type UpdateMemberRequest = {
		id: number;
		first_name?: string;
		last_name?: string;
		native_first_name?: string;
		native_last_name?: string;
		email?: string;
		status?: string;
		banned?: boolean;
		position?: string;
		department_id?: number;
		drop_department?: boolean;
		skype?: string;
		phone?: string;
	};
	class MembersApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		/**
		 *
		 * @param request
		 * "email" and one of "first_name" or "last_name" are required
		 */
		create(request: CreateMemberRequest): Promise<Person>;
		get({ id }: ById): Promise<Person>;
		getAll(request?: GetAllRequest): Promise<MembersResponse>;
		update(request: UpdateMemberRequest): Promise<Person>;
		delete({ id }: ById): Promise<Person>;
	}
	export type TaskRequest = {
		text?: string;
		formatted_text?: string;
		subject?: string;
		parent_task_id?: number;
		due_date?: Date;
		due?: Date;
		scheduled_date?: Date;
		scheduled_datetime_utc?: Date;
		cancel_schedule?: boolean;
		duration?: number;
		form_id?: number;
		attachments?: NewFile[];
		responsible?: PersonIdentity;
		fields?: FormFieldIdentified[];
		approvals?: PersonIdentity[][];
		subscribers?: PersonIdentity[];
		participants?: PersonIdentity[];
		list_ids?: number[];
		fill_defaults?: boolean;
	};
	class TasksApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		get({ id }: ById): Promise<TaskResponse>;
		/**
		 *
		 * @param request
		 * If "form_id" specified it will be Form task,
		 * else - Simple task.
		 */
		create(request: TaskRequest): Promise<TaskResponse>;
		addComment(id: number, request: TaskCommentRequest): Promise<TaskResponse>;
	}
	export type PrintForm = {
		print_form_id: number;
		print_form_name?: string;
	};
	export type FormResponse = {
		id: number;
		name: string;
		steps?: TaskSteps;
		fields: FormField[];
		print_forms?: PrintForm[];
		deleted_or_closed: boolean;
		business_owners?: number[];
		folder?: string[];
	};
	export type TaskSteps = {
		[index: number]: string;
	};
	export type FormsResponse = {
		forms: FormResponse[];
	};
	export type FormRegisterRequest = {
		steps?: number[];
		include_archived?: "y";
		modified_before?: Date;
		modified_after?: Date;
		created_before?: Date;
		created_after?: Date;
		closed_before?: Date;
		closed_after?: Date;
		filters?: FormFilter[];
		format?: "csv";
		delimiter?: string;
		simple_format?: boolean;
		encoding?: string;
		field_ids?: number[];
		task_ids?: number[];
		due_filter?: DueFilter;
		/**
		 * Max. number of tasks in request
		 * @remarks
		 * More than 0, and less than or equal to 20000
		 */
		item_count?: number;
	};
	export type FormRegisterResponse = {
		tasks: Task[];
	};
	export type PermissionsDict = {
		[index: string | number]: PermissionLevel;
	};
	export type PermissionsResponse = {
		permissions: PermissionsDict;
	};
	export type ChangePermissionsRequest = {
		permissions: PermissionsDict;
	};
	class FormsApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		get({ id }: ById): Promise<FormResponse>;
		getAll(): Promise<FormsResponse>;
		getTasks(id: number, request: FormRegisterRequest): Promise<FormRegisterResponse>;
		getPermissions({ id }: ById): Promise<PermissionsResponse>;
		setPermissions(id: number, request: ChangePermissionsRequest): Promise<PermissionsResponse>;
	}
	export type LogsParameters = {
		after?: number;
		count?: number;
	};
	class LogsApi extends BaseApi {
		getEvents(request?: LogsParameters): Promise<Blob>;
		getFileAccess(request?: LogsParameters): Promise<Blob>;
		getTaskAccess(request?: LogsParameters): Promise<Blob>;
		getTaskExport(request?: LogsParameters): Promise<Blob>;
		getRegistryDownload(request?: LogsParameters): Promise<Blob>;
	}
	export type CallRequest = {
		/**
		 * Unique ID of the extension's account in the external system
		 */
		account_id: string;
		/**
		 * Sender phone number
		 */
		from_number: string;
		/**
		 * Recipient phone number
		 */
		to_number: string;
		/**
		 * Internal operator number
		 */
		internal_number?: string;
		/**
		 * Call ID in external system
		 */
		external_id?: string;
		/**
		 * Data for autofill form fields
		 */
		mappings?: FormMapping[];
	};
	export type CallResponse = {
		task_id: number;
	};
	/**
	 * Adding information about the call
	 *
	 * @remarks
	 *
	 * To successfully process the request, one of the following parameters
	 * must be indicated: external_id, task_id or from_number and to_number
	 */
	export type AttachCallRecordRequest = {
		/**
		 *  Unique ID of the file uploaded with a /files/upload request
		 */
		record_file?: string;
		/**
		 * Sender phone number
		 */
		from_number?: string;
		/**
		 * Recipient phone number
		 */
		to_number?: string;
		/**
		 * Call ID in external system
		 */
		external_id?: string;
		/**
		 *  ID of the created task
		 *  @remarks
		 *  Returns to integrations/call.
		 */
		task_id?: number;
		/**
		 * Data for autofill form fields
		 */
		mappings?: FormMapping[];
	};
	class CallApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		registerCall(request: CallRequest): Promise<CallResponse>;
		attachCallRecord(request: AttachCallRecordRequest): Promise<void>;
	}
	export type CreateBotRequest = {
		name: string;
		hook_url?: string;
		external_id?: string;
	};
	export type Bot = {
		id: number;
		name: string;
		external_id?: string;
		is_enabled: boolean;
		fired?: boolean;
		hook_url: string;
		description: string;
		bot_settings: string;
		version: string;
		login: string;
		send_only_last_comment: boolean;
		locale?: string;
		time_zone_offset?: number;
	};
	export type BotsResponse = {
		bots: Bot[];
	};
	export type UpdateBotRequest = {
		id: number;
		name?: string;
		hook_url?: string;
		is_enabled?: boolean;
		bot_settings?: string;
		description?: string;
		rights?: PersonRights;
		send_only_last_comment?: boolean;
		locale?: string;
		time_zone_offset?: number;
	};
	export type DeleteBotRequest = {
		id: number;
		task_receiver_id: number;
	};
	class BotApi extends BaseApi {
		protected _moduleSubPath: Endpoints;
		create(request: CreateBotRequest): Promise<Bot>;
		getAll(request?: GetAllRequest): Promise<BotsResponse>;
		update(request: UpdateBotRequest): Promise<Bot>;
		delete(request: DeleteBotRequest): Promise<Bot>;
	}
	export class PyrusApiClient extends BaseApi {
		private _role;
		private _profile;
		private _contacts;
		private _files;
		private _lists;
		private _calendar;
		private _announcements;
		private _catalogs;
		private _members;
		private _tasks;
		private _forms;
		private _logs;
		private _call;
		private _bot;
		/**
		 *
		 * @param auth
		 * can be AuthRequest type or token
		 * @param settings
		 * connection settings
		 */
		constructor(auth: AuthRequest | string, settings?: Settings);
		private _authenticateClient;
		private static extendDefaults;
		private get initParams();
		get role(): RoleApi;
		get profile(): ProfileApi;
		get contacts(): ContactsApi;
		get files(): FilesApi;
		get lists(): ListsApi;
		get calendar(): CalendarApi;
		get announcements(): AnnouncementsApi;
		get catalogs(): CatalogsApi;
		get members(): MembersApi;
		get tasks(): TasksApi;
		get forms(): FormsApi;
		get logs(): LogsApi;
		get call(): CallApi;
		get bot(): BotApi;
	}
	
	export {};
	
}
